# 멀쩡한 사각형

## 설명
👩🏻‍💻[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/62048)

W * H 크기의 직사각형을 대각선으로 잘랐을 때, 사용 가능한 1 * 1 크기의 정사각형의 개수를 구하는 문제이다. 사실 전에 윈터코딩인가 때 접했던 문제지만 그 땐 방향조차 못잡고 처참히 실패했다...ㅎ 규칙을 찾기 위해 사각형을 10개 쯤 그려서 계산 과정을 쭉 적다 보니 무려 이번엔 규칙을 찾았다! 찾는 과정은 다음과 같았다.
1. 못쓰게 된 사각형 패턴이 수가 커지면서 반복된다.
2. 패턴이 반복되는 경우는 W와 H 사이에 1이 아닌 최대공약수가 존재할 때였고, 같은 패턴이 최대공약수만큼 반복된다. 반복되는 패턴은 두 수를 각각 최대공약수로 나눈 수로 만들어진 사각형의 패턴이다.
3. 즉, 서로소인 경우에는 패턴이 반복되지는 않는데 이 경우에는 W + H - 1만큼의 사각형을 못 쓰게 된다는 사실을 알아냈다.

여기까지 발견하고 식을 써보니 다음과 같았다.
```
gcd는 W와 H의 최대공약수일 때,
{(W/gcd + H/gcd) - 1} * gcd = 못 쓰는 사각형 개수
즉, W + H - gcd = 못 쓰는 사각형 개수
```

이렇게까지 간단해도 되냐구,,,^^ 근데 계산하고 보니 한 방에 W + H - gcd 라는 사실을 발견한 사람도 있겠지 싶다. 음 똑똑이들! 난 거의 운 좋게 알아낸 느낌인데!

그러나 처음 짠 코드는 테스트케이스를 전부 통과하진 못했다. W * H 가 int 범위를 넘었기 때문인데, 이를 long으로 변환하려면 먼저 W와 H를 각각 long으로 캐스팅해줘야 한다는 걸 몰라서 음청나게 헤맸다. 그래도 로직 자체에 대한 확신이 있어서 다른 삽질은 하지 않았다.

## 코드

```java
public class Solution {
    public long solution(int w, int h) {
        int gcd = calcGcd(w, h);
        long multiplied = (long)w * (long)h;
        return (multiplied - (w + h - gcd));
    }

    private int calcGcd(int w, int h) {
        while(h > 0) {
            int tmp = w;
            w = h;
            h = tmp%h;
        }
        return w;
    }
}
```

* `calcGcd` 함수로 w와 h의 최대공약수를 구한다. 최대공약수 구하기는 유클리드 호제법을 이용함.
* 두 수의 곱을 타입 캐스팅을 통해 long 변수에 저장한 뒤, 사용 가능한 사각형의 개수를 계산해서 반환한다.